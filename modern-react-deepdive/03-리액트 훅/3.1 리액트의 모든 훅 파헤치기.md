# 3.1 리액트의 모든 훅 깊게 살펴보기
### useState
함수 컴포넌트 내부에서 상태를 정의하고 이 상태를 관리할 수 있게 하는 훅
### useState 구현 살펴 보기
```javascript
import {useState} from 'react'

const [state, setState] = useState(initialState)
```
**훅의 인수**로는 state 의 초깃값 / 아무런 값을 넣어주지 않으면 초깃값은 undefined

**훅의 반환값**은 배열이며, 첫번째 원소는 state 값 자체, 두번째 원소는 setState 함수를 사용해 해당 state 값을 변경 가능

- useState 를 사용하지 않고 함수 내부에서 자체적으로 let 변수를 사용해 상태를 관리

동작 X => **렌더링** : 함수 컴포넌트의 return을 실행 한 후, **실행 결과를 이전 리액트 트리와 비교해 리렌더링이 필요한 부분**만 업데이트

- 두 번째 원소를 실행해 리액트에서 렌더링이 일어나게끔 변경
```javascript
functin Component (){
  const [,triggerRender] = useState();
  let state = 'hello';

  function handleButtonClick(){
    state = 'hi';
    triggerRender();
  }

  return (
    <>
    <h1>{state}</h1>
    <button onClick={handleButtonClick}>hi</button>
    </>
  )
}
```
hi 라는 값으로 동작 X => 렌더링은 반환한 결과물인 return의 값을 비교해 실행되기 때문!

매번 렌더링이 발생될 때 **함수는 새롭게 다시 실행**되고, **새롭게 실행되는 함수에서 state 는 매번 hello로 초기화**되므로 아무리 state 를 변경해도 다시 hello로 초기화
=> 따라서 함수 컴포넌트는 **매번 함수를 실행해 렌더링**이 일어나고, 함수 내부의 값은 함수가 실행될 때마다 다시 초기화

<br />

어떻게 useState는 state 값을 유지 할 수 있는 걸까?
**useState 가 어떤 구조**를 가지는 지 살펴보자
```javascript
function useState(initialValue){
  let internalState = initialValue

  function setState(newValue){
    internalState = newValue
  }

  return [internalState, setState]
}
```
이 또한 원하는 대로 동작X
```javascript
const [value, setValue] = useState(0);

setValue(1);
console.log(value); // 0
```
**이미 구조분해 할당으로 value, state 값을 이미 할당해 놓은 상태**이기 때문에 훅 내부 setState를 호출하더라도 변경된 새로운 값을 반환하지 X
<br />


- state 를 함수로 바꿔서 state 값을 호출할 때마다 현재 state 를 반환하게

```javascript
function useState(initialValue){
  let internalState = initialValue

  function state () {
    return internalState
  }

  function setState(newValue){
    internalState = newValue
  }

  return [state, setState]
}

const [value, setValue] = useState(0)
setValue(1)
console.log(value()) // 1
```
하지만 useState 훅의 모습과 다르다 => 함수가 아닌 상수 처럼 사용!

- **클로저를 이용**
여기서 클로저는 useState 내부에서 선언된 함수 setState 가 함수의 실행이 종료된 이후에도 지역 변수인 state 를 계속 참조할 수 있다

매번 실행되는 함수 컴포넌트 환경에서 state 의 값을 유지하고 사용하기 위해서 리액트는 클로저를 활용

MyReact 라고 불리는 클로저 내부에 useState 와 관련된 정보를 저장해두고, 이를 필요할 때마다 꺼내놓는 형식으로 구성

### 게으른 초기화
useState 에서 기본값을 선언하기 위해 useState 원시 값을 넣는 경우가 많음

**게으른 초기화** : useState 에 변수 대신 함수를 넘기는 것

```javascript
// 일반적인 useState 사용
// 바로 초기값을 인자에 넣어줌
const [count, setCount] = useState(Number.parseInt(window.localStorage.getItem(cacheKey)))

// 게으른 초기화
// 함수를 실행해 값을 반환
const [count, setCount] = useState(() => Number.parseInt(window.localStorage.getItem(cacheKey)))
```
게으른 초기화는 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용
=> 게으른 초기화 함수는 오로지 state 처음 만들어질 때만 사용
=> 리렌더링이 발생되면 함수의 실행 무시

> 렌더링이 실행될 때마다 함수 컴포넌트의 함수 다시 실행! => 즉 useState 또한 다시 실행
useState 인수 값이 자바스크립트에 많은 비용을 요구하는 작업이 들어가 있다면 이는 계속해서 실행될 위험이 존재
=> 따라서 최초 렌더링 이후에는 실행되지 않고 최초의 state 값을 넣을 때만 실행

useState 인수 값이 **자바스크립트에 많은 비용을 요구하는 작업**이 들어가 있다면 초깃값이 필요한 최초 렌더링과 초깃값이 있어 더 이상 필요 없는 리렌더링 시에도 **동일하게 계속 해당값에 접근해서 낭비가 발생**

그래서 게으른 초기화는 useState 의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 때 사용하여,

오직 state 가 처음 만들어질 때만 함수가 사용되며, **리렌더링될 때는 함수 실행은 무시되고 기존 값을 사용**