# 1.5 이벤트 로프와 비동기 통신의 이해

자바스크립트는 싱글 스레드에서 동작
=> 한번에 하나의 작업만 동기방식으로 처리

> 동기 : 직렬 방식으로 작업을 처리하는 것 (한번에 다양한 많은 작업을 처리 X)
>
> 비동기 : 직렬 방식이 아닌 병렬 방식으로 작업을 처리하는 것
> (요청을 시작한 후 응답이 오건 말건 다음 작업 수행)

이러한 싱글 스레드 기반의 자바스크립트에서 많은 비동기 작업이 이루어 지고 있다.

### 싱글 스레드 자바스크립트

과거에는 프로그램을 실행하는 단위가 오직 프로세스

> 프로세스 : 프로그램을 구동해 프로그램의 상태가 메모리 상에서 실행되는 작업 단위
>
> => 프로그램 실행은 하나의 프로세스를 가지고 프로세스 내부에서 모든 작업이 처리
>
> 현재에는 하나의 프로그램에서 동시에 여러 개 복잡한 작업을 수행할 필요가 있음

> 스레드 : 작은 실행 단위
>
> => 하나의 프로세스에서 여러 개 스레드를 만들 수 있고, 스레드 끼리 메모리 공유할 수 있어 여러 가지 작업을 동시에 수행할 수 있음

단점: 처리가 복잡, 동시성 문제

초기 자바스크립트는 아주 기초적인 수준에서만 제한적으로 사용되었다.

### 자바스크립트 싱글 스레드

자바스크립트의 코드의 실행이 하나의 스레드에서 순차적으로 이루어 진다

Run-to-completion : 하나의 코드가 실행하는 데 오래 걸리면 뒤이은 코드가 실행되지 않는다는 것

=> 어떠한 작업이 오래 걸리면 사용자에게 웹페이지가 멈춘것 같은 느낌을 줄 수 있음

### 자바스크립트 비동기 함수

자바스크립트에서 비동기 함수를 선언할 때 async 쓴다

동기식과 다르게 여러 작업을 동시에 수행할 수 있다.

### 이벤트 루프란?

이벤트 루프란 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

#### 호출 스택과 이벤트 루프

호출스택은 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택

```javascript
function bar() {
  console.log("bar");
}
function baz() {
  console.log("baz");
}
function foo() {
  console.log("foo");
  setTimeout(bar(), 0);

  baz();
}
```

- 호출 스택

1. foo() 호출 스택에 들어감
2. foo 내부 콘솔이 존재해 호출 스택에 들어감
3. setTimeout 이 호출 스택에 들어감
4. 타이머 이벤트가 실행되며 태스크 큐로 들어가고 바로 스택에서 제거
5. baz 호출 스택에 들어감
6. baz 내부 콘솔이 존재해 호출 스택에 들어감
7. baz, foo 남은 것이 없어 호출 스택에 제거
8. 이벤트 루프가 호출 스택이 비워져있다는 것을 확인 => bar 를 호출스택에 들여보냄
9. bar 내부 콘솔이 존재해 호출 스택에 들어감
10. bar 남은 것이 없어 호출 스택에 제고

이벤트 루프는 호출 스택이 비어있는 지 여부를 확인하는 것

=> 이벤트 루프만의 단일 스레드 내부에서 호출 스택 내부에 수행해야 할 작업이 있는 지 확인하고, 수행해야할 코드가 있다면 자바스크립트 엔진을 이용해 실행

테스크 큐는 실행해야 할 태스크의 집합
(실행해야 할 태스크 란 비동기 함수의 콜백 함수나 이벤트 핸들러를 의미)

따라서 이벤트의 루프는 호출 스택에 실행 중인 코드가 있는 지, 태스크 큐에 대기중인 함수가 있는 지 반복해서 확인하는 역할을 수행

호출 스택이 비였다면 태스크 큐에 대기 중인 작업이 있는 지 확인하고, 실행 가능한 오래된 것부터 순차적으로 꺼냄

#### 비동기 함수

비동기 함수는 누가 수행할까?

자바스크립트 코드가 동기식으로 실행되는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행!

=> 코드 실행은 싱글 스레드에서만 이루어지지만, 외부 API 등은 자바스크립트 외부에서 실행되고 콜백이 태스크 큐로 들어감

### 태스크 큐와 마이크로 태스크 큐

기존의 태스크 큐와는 다르게 태스크를 처리

마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 가짐

- 태스크 큐 : setTimeout, setInterval, setImmediate
- 마이크로 태스크 큐 : process.nextTick, Promises, queueMicroTask, MutationObserver

그럼 렌더링은 언제 실행될까?

태스크 큐를 실행하기에 앞서 먼저 마이크로 태스크 큐를 실행하고, 이 마이크로 태스크 큐를 실행한 뒤에 렌더링이 일어난다.

```javascript
// 동기 코드로 버튼 1에 렌더링
sync.addEventListener("click", function () {
  for (let i = 0; i <= 100000; i++) {
    sync.innerHTML = i;
  }
});

// setTimeout 으로 태스크 큐에 작업을 넣어서 1부터 렌더링
macrotask.addEventListener("click", function () {
  for (let i = 0; i <= 100000; i++) {
    setTimeout(() => {
      macrotask.innerHTML = i;
    }, 0);
  }
});

// queueMicrotask 로 마이크로 태스크 큐에 넣어서 1부터 렌더링
microtask.addEventListener("click", function () {
  for (let i = 0; i <= 100000; i++) {
    queueMicrotask(() => {
      microtask.innerHTML = i;
    }, 0);
  }
});
```

동시에 실행했을 경우 동기 코드와 마이크로 태스크 큐만 한번에 숫자가 올라가고, 태스크 큐만 앞선 예전처럼 순차적으로 렌더링되는 것을 확인할 수 있다.
