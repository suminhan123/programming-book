# 2.4 렌더링은 어떻게 일어나는가

브라우저에서의 렌더링 : 쉽게 말해 HTML과 CSS 리소스를 기반으로 웹 페이지에 필요한 UI를 그리는 과정

리액트의 렌더링 : 브라우저가 렌더링에 필요한 DOM트리를 만드는 과정

### 리액트의 렌더링이란?

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props 와 state 의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것이지 계산하는 일련의 과정을 의미

### 리액트의 렌더링이 일어나는 이유

- 최초의 렌더링
- 리렌더링

1. 클래스 컴포넌트의 setState 가 실행되는 경우
2. 클래스 컴포넌트의 forceUpdate 가 실행되는 경우
3. 함수 컴포넌트의 useState() 두번째 요소인 setter가 실행되는 경우
4. 컴포넌트의 key props 가 변경되는 경우
   > 키가 필요한 이유는?
   >
   > 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값이다.
   >
   > 동일한 자식 컴포넌트가 여러 개 있는 구조를 상상해보자. 리렌더링이 발생하면 current 트리와 workInProgress 트리 사이에서 어떠한 컴포넌트가 변경이 있었는 지 구별해야 하는데 이 두 트리 사이에서 같은 컴포넌트인지를 구별하는 값이 바로 key 값이다.
5. props 가 변경되는 경우
6. 부모 컴포넌트가 렌더링될 경우 : 부모 컴포넌트가 리렌더링된다면 자식 컴포넌트도 무조건 리렌더링이 일어난다

### 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.

만약 여기서 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 함수 컴포넌트의 경우 FunctionComponent() 그 자체를 호출한 뒤에 그 결과물을 저장한다.

렌더링 결과물은 JSX 문법으로 구성돼있고, 이것이 자바스크립트로 컴파일 되면서 React.createElement() 를 호출하는 구문으로 변환된다.

여기서 createElement 는 브라우저의 UI구조를 설명할 수 있는 일반적인 자바스크립트 객체를 반환한다.

=> 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경사항을 차례로 수집

### 렌더와 커밋

렌더 단계 : 렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계 => 여기서 비교하는 것은 크게 세가지, type,props, key

커밋 단계 : 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정

리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면, 이렇게 만들어진 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다.

**리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것이 아니다!**

리액트의 렌더링은 항상 동기적으로 작동한다.

=> 몇 가지 상황에서는 비동기 렌더링 시나리오가 유효할 수 있다

=> 이때 의도된 우선순위로 컴포넌트를 렌더링해 최적화할 수 있는 비동기 렌더링, 동시성 렌더링을 활용

### 일반적인 렌더링 시나리오 살펴보기

```javascript
export default function A() {
  return (
    <div>
      <h1>Hello</h1>
      <B />
    </div>
  );
}

function B() {
  const [counter, setCounter] = useState(0);
  const handleButtonClick = () => {
    setCounter((counter) => counter + 1);
  };

  return (
    <>
      <C number={counter}>
      <button onClick={handleButtonClick}>+</button>
    </C>
  )
}

function C({number}) {
  return (
    <>
      {number}
      <D />
    </C>
  )
}

function D(){return <>hello</>}
```

1. B 컴포넌트의 setState가 호출된다.
2. B 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 렌더링 경로를 검사한다.
4. A 컴포넌트는 리렌더링이 필요한 컴포넌트로 표시돼 있지 않으므로 별다른 작업을 하지 않는다.
5. 그 다음 하위 컴포넌트인 B 컴포넌트는 업데이트가 필요하다고 체크돼 있으므로 B를 리렌더링한다.
6. 5번에서 B는 C를 반환했다.
7. C는 props 인 number 가 업데이트 됐다. 그러므로 업데이트가 필요한 컴포넌트로 체크돼 있고 업데이트한다.
8. 7번 과정에서 C는 D를 반환했다.
9. D도 마찬가지로 업데이트가 필요한 컴포넌트로 체크되지 않았다. 그러나 C가 렌더링됐으므로 그 자식인 D도 렌더링 됐다.

부모가 변경됐다면 props 가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링 된다.

만약 D 컴포넌트에 memo를 추가하면 어떻게 될까?

```javascript
const D = memo(() => {
  return <>hello</>;
});
```

memo로 래핑돼있어 렌더링이 일어나지 않는다!

렌더 단계에서 컴포넌트 비교를 거쳤지만 memo로 선언한 덕분에 props 가 변경되지 않으면 렌더링이 생략되므로 커밋 단계도 생략된다.
