# 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

### 주장1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다.

```javascript
function sum(a, b) {
  return a + b;
}
```

매우 간단한 연산을 수행하는 함수의 예제가 있다.

sum(1, 1)의 결과를 저장해두고 다시 실행될 때 메모리에서 그 값을 꺼내오는 게 나을까?

아니면 단순히 자바스크립트에 1+1을 실행시키는 게 나을까

값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업, 그리고 이전에 결과물을 저장해 두었다가 다시 껴내와야 한다는 두 가지 비용이 있다.

항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.

메모이제이션은 항상 어느정도의 트레이드 오프가 있는 기법이라고 보는 것이 옳다. 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유하게 된다.

메모이제이션으로 인한 성능 개선이 렌더링보다 낫지 않다면 결국 안하느니만 못하는 상황을 마주하게 된다는 것이다.

### 주장2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해버리자

일단 memo로 감싼 뒤에 생각해보자

잘못된 컴포넌트에 이뤄진 최적화, 즉 렌더링 비요잉 저렴하거나 사실 별로 렌더링이 안 되는 컴포넌트에 memo 를 썼을 때 역으로 지불해야 하는 비용을 생각해보쟈

잘못된 memo로 지불해야 하는 비용은 바로 props 에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다.

> 메모이제이션을 위해서는 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해 둬야 하고, 리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다. => 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다

반면 memo를 하지 않았을 때 발생하는 문제는 다음과 같다

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 그리고 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어남
- 리액트가 구 트리와 신규 트리를 비교

memo를 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다

useMemo와 useCallback 을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정과 이러한 처리 없이 값과 함수를 매번 재생성하는 비용 중에서 무엇이 더 저렴한지 매번 계산해야 한다.

=> 리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다.

=> 변경된 참조로 인해 다른 사용하는 쪽에 영향을 미치게 된다.

=> useMemo로 감싸게 되면 값이 변경되지 않는 한 같은 결과물을 가질 수 있고, 그 덕분에 사용하는 쪽에서도 참조의 투명성을 유지할 수 있게 된다.
