# 5.1 상태 관리는 왜 필요한가?

흔히 웹 애플리케이션을 개발할 때 이야기하는 상태는 **어떠한 의미를 지닌 값이며, 웹 애플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미**한다.

상태로 분류되는 것으로는 UI, URL, 폼, 서버에서 가져온 값 등이 있다.

=> 웹 서비스에서 점차 다양한 기능이 제공됨에 따라 웹 내부에서 괸리해야 할 상태도 점차 비례해서 증가하고 있다.

애플리케이션 전체적으로 관리해야 할 상태가 있다고 가정해보자

그러면 상태를 어디에 두지? 전역 변수에 둘 것인가? 별도의 클로저를 만들 것인가?그렇다면 그 상태가 유효한 범위는 어떻게 제한할 수 있을까? 상태 변화에 따라 변경돼야하는 자식 요소들은 어떻게 이 상태의 변화를 감지할 것인가? 이러한 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상을 어떻게 방지할 것인가?

상태를 어떻게 효율적으로 관리하고, 상태가 필요한 쪽에서는 빠르게 반응할 수 있는 모델에 대해 고민해보자

## 5.1.1 리액트 상태 관리의 역사

리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리 뿐이고, 그 이상의 기능을 제공하지 않고 있다.

그렇기 때문에 관리하는 방법에 따라 개발자에 따라 시간에 따라 많은 차이가 있다.

리액트 생태계에서 개발자들이 상태 관리를 활용하기 위해 어떠한 방법을 활용했는 지 그 역사를 살펴보자

### Flux 패턴의 등장

리액트에서 할 수 있는 전역 상태 관리 수단이라고 하면 Context API를 떠올릴 것이다.
(명확하게는 상태를 주입하는 역할!)

2014년 경 리액트의 등장과 비슷한 시기에 Flux 패턴과 함께 이를 기반으로 한 라이브러리인 Flux를 소개한다.

![image](https://github.com/user-attachments/assets/3cdb0e6c-14f6-481d-879c-b7b39d4d2316)

그 당시 웹 환경은 웹 애플리케이션이 비대해지고 상태도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는 지 추적하고 이해하기 어려운 상황이었다.

**문제 원인은 양방향 데이터 바인딩!**

뷰(html)가 모델(js) 을 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경할 수 있다.

코드의 양이 많아 지고 변경 시나리오가 복잡해질 수록 관리가 어려워진다.

**단방향으로 데이터 흐름을 변경하자**

![image](https://github.com/user-attachments/assets/07439bc4-0faf-4c5b-85ca-0631e6dd5839)

양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하는 데 이것이 바로 Flux 패턴의 시작이다!

- action : 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.

- dispatcher : 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.

- store : 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메소드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.

- view : 리액트의 컴포넌트에 해당하는 부분으로, 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것이다. 이 경우에는 그림과 같이 뷰에서 액션을 호출하는 구조로 구성된다.

단방향 데이터 흐름 방식은 사용자 입력에 따라 데이터를 갱신하고 화면을 어떻게 업데이트해야 하는 지도 코드로 작성해야 하므로 코드 양이 많아진다.

=> 데이터의 흐름은 모두 액션이라는 한방향으로 줄어들므로 데이터의 흐름을 추적하기 쉽고 코드를 이해하기가 한결 수월해진다.

### 시장 지배자 리덕스의 등장

리덕스는 최초의 이 Flux 구조를 구현하기 위해 만들어진 라이브러러

이는 Elm 아키텍처를 도입했다.

리덕스는 하나의 상태 객체를 스토어에 저장해두고, 이 객체를 업데이트하는 작업을 디스패치해 업데이트를 수행한다.

이러한 작업은 reducer 함수로 발생시킬 수 있는데, 이 함수의 실행은 웹 애플리케이션 상태에 대한 완전히 새로운 복사본을 반환한 다음, 애플리케이션에 이 새롭게 만들어진 상태를 전파한다.

**장점**

- props 내려주기 문제 해결

  하나의 글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있다.

**단점**

- 하고자 하는 일에 비해 보일러 플레이트가 너무 많다

  단순히 하나의 상태를 바꾸고 싶다면, 어떠한 액션인지 타입을 선언해야하고, 이액션을 수행하기 위한 creator, 함수를 만들어야 한다. 그리고 dispatcher와 selector 도 필요하고, 새로운 상태가 어떻게 기존의 리듀서 내부에서 어떤 식으로 변경돼야할 지 혹은 새로 만들어야 할지도 새로 정의...

### Context API와 useContext

상태를 어떻게 적절하게 주입해야 하는지에 대한 고민은 계속 이어져왔다.

부모에 있는 상태를 자식 컴포넌트에서 쓰기 위해서는 props 내려주기 방식이 있지만 이는 자식 컴포넌트의 깊이가 깊어질 수록 props 가 컴포넌트를 관통해 버리는 현상 발생

또한, 리덕스는 단순히 상태를 참조하고 싶을 때뿐 준비해야하는 보일러플레이트가 부담,,

=> 리액트 팀은 전역 상태를 하위 컴포넌트에 주입할 수 있는 Context API를 출시

props 로 상태를 넘겨주지 않더라도 Context API를 사용하면 원하는 곳에서 Context Provider 가 주입하는 상태를 사용할 수 있다.

### 훅의 탄생, 그리고 React Query와 SWR

Context API가 선보인지 1년이 채 되지 않아 리액트는 함수 컴포넌트에 사용할 수 있는 다양한 훅 API를 추가했다.

훅 API는 기존에 무상태 컴포넌트를 선언하기 위해서만 제한적으로 사용됐던 함수 컴포넌트가 클래스 컴포넌트 이상의 인기를 구가할 수 있도록 많은 기능을 제공

```javascript
function useCount() {
  const [counter, setCount] = useState(0);

  function increase() {
    setCount((prev) => prev + 1);
  }

  return { count, increase };
}
```

state를 매우 손쉽게 재사용 가능해 개발자 들은 앞다투어 자신만의 훅을 만들어내기 시작했다.

이러한 훅과 state의 등장으로 이전에는 볼 수 없던 방식의 상태 관리가 등장하는데 바로 React Query와 SWR이다.

두 라이브러러는 모두 외부에서 데이터를 불러오는 fetch를 관리하는 데 특화된 라이브러리이지만, API 호출에 대한 상태를 관리하고 있기 때문에 http 요청에 특화된 상태 관리 라이브러리이다.

### Recoil, Zustand, Jotai, Valtio에 이르기까지

SWR과 React Query가 HTTP요청에 대해서만 쓸 수 있다면 좀 더 범용적으로 쓸 수 있는 상태 관리 라이브러리엔 어떤 변화가 있었을까?

훅이라는 새로운 패러다임의 등장에 따라, 훅을 활용해 상태를 가져오거나 관리할 수 있는 다양한 라이브러리가 등장하게 된다.

```javascript
// Recoil
const counter = atom({ key: "count", default: 0 });
const todoList = useRecoilValue(counter);

// Jotai
const countAtom = atom(0);
const [count, setCount] = useAtom(countAtom);

// Zustand
const useCounterStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
}));
const count = useCounterStore((state) => state.count);

// Valtio
const state = proxy({ count: 0 });
const snap = useSnapshot(state);
state.count++;
```

기존의 리덕스와 같은 라이브러리와는 차이점은 바로 훅을 활용해 작은 크기의 상태를 효율적으로 관리한다.
