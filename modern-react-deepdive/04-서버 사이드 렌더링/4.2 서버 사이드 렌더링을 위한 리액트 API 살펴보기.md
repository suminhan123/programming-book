# 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

서버에서 리액트 코드가 어떻게 HTML로 변경되지?
이렇게 만들어진 HTML에 자바스크립트 코드를 어떻게 추가하지?

리액트에서 리액트 애플리케이션을 서버에서 렌더링할 수 있는 API 제공
=> 브라우저의 window 환경이 아닌 Node.js 서버 환경에서만 실행할 수 있음

서버 사이드 렌더링을 실행할 때 사용되는 API를 확인해보려면 리액트 저장소의 react-dom/server.js 를 확인
=> react-dom 이 서버에서 렌더링하기 위한 다양한 메소드를 제공

## 4.2.1 renderToString

인수로 넘겨 받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수
최초의 페이지를 HTML로 먼저 렌더링하는 역할을 하는 함수가 renderToString

```javascript
function ChildrenComponent({ fruits }: { fruits: Array<string> }) {
  useEffect(() => {
    console.log(fruits);
  }, [fruits]);

  function handleClick() {
    console.log("hello");
  }

  return (
    <ul>
      {fruits.map((fruit) => (
        <li key={fruit} onClick={handleClick}>
          {fruit}
        </li>
      ))}
    </ul>
  );
}
```

```javascript
function SampleComponent() {
  return (
    <>
    <div>hello</div>
    <ChildrenComponent fruits={['apple', 'banana', 'peach']}>
    </>
  )
}
```

```javascript
import ReactDOMServer from "react-dom/server";
const result = ReactDOMServer.renderToString(
  React.createElement("div", { id: "root" }, <SampleComponent />)
);
```

위 result 는 다음과 같은 문자열을 반환

```javascript
<div id="root" data-reactroot="">
  <div>hello</div>
  <ul>
    <li>apple</li>
    <li>banana</li>
    <li>peach</li>
  </ul>
</div>
```

renderToString 을 사용해 실제 브라우저가 그려야 할 HTML 결과를 만들어냄
=> 해당 렌더링은 루트 컴포넌트인 `<div id="root" />` 에서 수행해 완성된 HTML을 반환

단 ChildrenComponent 에 있는 useEffect 와 handleClick 과 같은 이벤트 핸들러는 결과물에 포함되지 X

=> renderToString 은 인수로 주어진 리액트 컴포넌트를 기준으로 빠르게 **브라우저가 렌더링할 수 있는 HTML을 제공하는 데 목적이 있는 함수**일 뿐!

=> 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 수행 X

=> **필요한 자바스크립트 코드는 생성된 HTML과는 별도로 제공해 브라우저에 제공**되어야 함

renderToString 을 사용하면 완성된 HTML을 서버에서 제공할 수 있으므로 초기 렌더링에서 뛰어난 성능을 보인다

검색 엔진이나 SNS 공유를 위한 메타 정보도 renderToString 에서 미리 준비한 채로 제공할 수 있다

따라서,
서버 사이드렌더링은 실제로 웹페이지가 사용자와 인터랙션할 준비가 되기 위해서는 별도의 자바스크립트를 모두 다운로드, 파싱, 실행하는 과정이 필요

또한, div#root 에 존재하는 속성인 data-reactroot 는 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할
=> 해당 속성은 자바스크립트를 실행하기 위한 hydrate 함수에서 루트를 식별하는 기준점

## 4.2.2 renderToStaticMarkup

renderToString 과 매우 유사한 함수
두 함수 모드 리액트 컴포넌트를 기준으로 HTML 문자열을 만든다

차이점은 루트 요소에 추가한 **data-reactroot 와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 X**
=> 리액트에서만 사용하는 속성을 제거하면 HTML의 크기를 조금이라도 줄일 수 있다

```javascript
import ReactDOMServer from "react-dom/server";
const result = ReactDOMServer.renderToStaticMarkup(
  React.createElement("div", { id: "root" }, <SampleComponent />)
);
```

```javascript
<div id="root">
  <div>hello</div>
  <ul>
    <li>apple</li>
    <li>banana</li>
    <li>peach</li>
  </ul>
</div>
```

data-reactroot 가 사라진 완전히 순수한 HTML 문자열을 반환

해당 결과로 렌더링을 수행하면 클라이언트에서는 **리액트에서 제공하는 브라우저 API 절대로 실행 X**

renderToStaticMarkup 결과물을 기반으로 이벤트 리스너를 등록하는 hydrate 를 수행하면 서버와 클라이언트의 내용이 맞지 않는다는 에러가 발생
=> hydrate 를 수행해도 브라우저에서 클라이언트에서 완전히 새롭게 렌더링하게 된다

따라서
리액트의 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 만들 때 사용

## 4.2.3 renderToNodeStream

renderToNodeStream 은 renderToString 과 결과물이 완전히 동일하지만 두 가지 차이점이 존재

- renderToString 과 renderToStaticMarkup 은 브라우저에서도 실행할 수 있지만 **renderToNodeStream은 브라우저에서 사용하는 것이 완전히 불가능**

  renderToNodeStream이 완전히 Node.js 환경에 의존!

- 결과물의 타입이 renderToString은 string 인 문자열이지만, **renderToNodeStream의 결과물은 Node.js의 ReadableStream**

> ReadableStream 타입
>
> 해당 타입은 utf-8로 인코딩된 바이드 스트림으로, Node.js 나 Deno, Bun 같은 서버 환경에서만 사용 가능
>
> 브라우저가 원하는 결과물, 즉 string 을 얻기 위해서는 추가적인 처리가 필요!

=> ReadableStream 객체는 브라우저에서도 사용할 수 있지만 **ReadableStream 을 만드는 과정이 브라우저에서 불가능하게 구현**되어 있다

<br />
그렇다면 renderToNodeStream이 왜 필요할까?

유튜브와 같이 웹에서 동영상을 보는 상황을 상상해보자

유튜브 영상을 보기 위해 전체 영상을 모두 다운로드 할 때까지 기다리지 X => 사용자가 볼 수 있는 몇 초라도 먼저 다운로드 되면 그 부분을 보여주고 이후 계속 영상을 다운로드

**스트림**은 **큰 데이터를 다룰 때 데이터를 청크(chunk, 작은 단위)로 분할해 조금씩 가져오는 방식**을 의미

renderToString 이 생성하는 HTML 결과물의 크기가 작다면 한 번에 생성하든 스트림으로 하든 문제가 X

그러나 **renderToSTring 으로 생성하는 HTML의 크기가 매우 크면??**

크기가 큰 문자열을 **한번에 메모리에 올려두고 응답을 수행해야 해서 Node.js 가 실행되는 서버에 큰 부담**!

=> 따라서 스트림을 활용하면 이러한 큰 크기의 데이터를 청크 단위로 분리해 순차적으로 처리할 수 있다

```typescript
export default function App({ todos }: { todos: Array<TodoResponse> }) {
  return (
    <>
      <h1>나의 할일!</h1>
      <ul>
        {todos.map((todo, index) => (
          <Todo key={index} todo={todo} />
        ))}
      </ul>
    </>
  );
}
```

App 은 todos를 순회하여 렌더링하는데 todos가 엄청 많다고 하면 모두 한번에 렌더링하려고 하기에 renderToString 으로 하면 시간이 많이 소요

```javascript
// Node.js 코드
(async () => {
  const response = await fetch("--");

  try {
    for await (const chunk of reponse.body) {
      console.log("---chunk---");
      console.log(Buffer.from(chunk).toString());
    }
  } catch (err) {
    console.error(err.stack);
  }
})();
```

```
node watch-stream.js
```

이렇게 renderToNodeStream으로 렌더링하면 **응답으로 오는 HTML이 여러 청크로 분리돼 내려온다**

=> 만약 renderToSTring 을 사용했다면 HTTP 응답은 거대한 HTML 파일이 완성될 때까지 기다려야 한다...

스트림을 활용한다면 **브라우저에 제공해야 할 큰 HTML을 작은 단위로 쪼개 연속적으로 작성함으로써 리액트 애플리케이션을 렌더링하는 Node.js 서버의 부담을 덜 수 있다**

## 4.2.4 renderToStaticNodeStream

renderToNodeStream 과 제공하는 결과물은 동일하나 renderToStackMarkUp과 마찬가지고 리액트 자바스크립트에 필요한 리액트 속성이 제공 X

=> hydrate 를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드

## 4.2.5 hydrate

앞에 함수를 통해 **생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할**

renderToString 결과물은 단순히 서버에서 렌더링한 HTML 결과물로 사용자에게 보여줄 수 있지만 사용자가 페이지와 인터렉션은 불가능!!

=> hydrate 는 정적으로 생성된 HTML에 이밴트 핸들러를 붙여 완전한 웹페이지 결과물을 생성!

<br />

**hydrate 와 비슷한 브라우저에서만 사용되는 메서드 : render**

- CRA로 생성한 프로젝트의 index.jsx

```javascript
import * as ReactDOM from "react-dom";
import App from "./App";

const rootElement = document.getElementById("root");

ReactDom.render(<App />, rootElement);
```

인수로 받은 두 정보를 바탕으로 **HTML의 요소에 해당 컴포넌트를 렌더링하며, 여기에 이벤트 핸들러를 붙이는 작업까지** 모두 한번에 수행

=> render 는 클라이언트에서만 실행되는 렌더링과 이벤트 핸들러 추가 등 리액트를 기반으로 온전하 웹을 만드는 모든 작업을 수행

**hydrate 메소드**

hydrate 는 render 와 인수를 넘기는 것이 거의 유사

```javascript
import * as ReactDOM from 'react-dom'
import App from './App

// containerId 를 가리키는 element 는 서버에서 렌더링된 HTML의 특정 위치를 의미
const element = document.getElementById(containerId)
// 해당 element 를 기준으로 리액트 이벤트 핸들러를 붙인다
ReactDOM.hydrate(<App />, element)
```

render 의 차이점은 hydrate 는 **기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 이 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 시행**

만약 hydrate 의 두번째 인수로 renderToStaticMarkup 등으로 생성된 리액트 관련 정보가 없는 순수한 HTML 정보를 넘겨준다면?

```html
<!DOCTYPE html>
<head>
  <title>React App</title>
</head>
<body>
  <!-- root 에 아무런 HTML도 없다 -->
  <div id="root"></div>
</body>
</html>
```

```javascript
import * as ReactDom from "react-dom";

function App() {
  return <span>안녕하세요</span>;
}

const rootElement = document.getElementById("root");

// Warning: expected server HTML to contain a matching <span> in <div>
//  at span
//  at App
ReactDom.hydrate(<App />, rootElement);
```

서버에서 제공받은 HTML에 App 컴포넌트에 있는 것과 마찬가지로 span 이 있기를 기대했지만 해당 요소가 없다는 경고 문구가 출력

=> **hydrate가 서버에서 제공해준 HTML이 클라이언트의 결과물과 같을 것이라는 가정하에 실행**된다!

=> 따라서 rootElement 내부에는 `<App />` 을 렌더링한 정보가 이미 포함돼 있어야만 hydrate 를 실행

hydrate 로 넘겨준 두번째 인수에는 이미 renderToString 등으로 렌더링된 정적인 HTML정보가 담겨 있어야 한다

<br />

hydrate 는 단순히 이벤트 핸들러를 추가하는 것 이외에도 **렌더링을 한 번 수행하면서 hydrate 가 수행한 렌더링 결과물 HTML과 인수로 넘겨받은 HTML을 비교하는 작업을 수행**

=> 여기서 불일치가 바로 에러의 원인! 불일치가 발생하면 hydrate 가 렌더링한 기준으로 웹페이지를 그린다

=> 이렇게 렌더링을 하면 **서버와 클라이언트에서 두 번 렌더링을 수행하고, 결국 서버 사이드 렌더링의 장점을 포기**

하지만 불가피하게 결과물이 다를 수 밖에 없는 경우도 존재

예를 들어,

HTML 내부에서 현재 시간을 초단위까지 기록해야 한다고 할 때

```javascript
<div>{new Date().getTime()}</div>
```

서버 사이드 렌더링과 hydrate 가 아무리 빨리 끝난다고 해도 불일치가 발생할 수 밖에 결국 hydrate 에러가 발생

이런 경우 해당 요소에 suppressHydrationWarning 을 추가해 경고를 끌 수 있다

=> 필요한 곳에서만 제한적으로 사용!!

=> 차라리 서버에서 실행하는 것보다 차라리 useEffect 를 통해 노출하는 편이 더 정확하므로 서버에서 굳이 해당 함수를 실행 하지 않는 것이 나을 수 있다
